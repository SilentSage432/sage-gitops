apiVersion: v1
kind: Service
metadata:
  name: sage-api
  namespace: arc-ui
  labels:
    app: sage-api
spec:
  selector:
    app: sage-api
  ports:
    - name: http
      port: 3000
      targetPort: 3000
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sage-api
  namespace: arc-ui
  labels:
    app: sage-api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sage-api
  template:
    metadata:
      labels:
        app: sage-api
    spec:
      serviceAccountName: sage-api
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        seccompProfile:
          type: RuntimeDefault
      tolerations:
      - key: "node-role.kubernetes.io/control-plane"
        operator: "Exists"
        effect: "NoSchedule"
      containers:
      - name: api
        image: python:3.11-alpine
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          capabilities:
            drop:
              - ALL
          seccompProfile:
            type: RuntimeDefault
        ports:
        - containerPort: 3000
        command: ["python", "-c"]
        args:
        - |
          import http.server
          import json
          import urllib.parse
          import os
          import sys
          import ssl
          from datetime import datetime
          from urllib.request import Request, urlopen, HTTPSHandler, build_opener
          from urllib.error import URLError, HTTPError
          
          class APIHandler(http.server.BaseHTTPRequestHandler):
              def do_GET(self):
                  self.handle_request()
              
              def do_POST(self):
                  self.handle_request()
              
              def do_OPTIONS(self):
                  self.send_cors_headers()
                  self.send_response(204)
                  self.end_headers()
              
              def send_cors_headers(self):
                  self.send_header('Access-Control-Allow-Origin', '*')
                  self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
                  self.send_header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
              
              def get_platform_signal(self, timestamp):
                  """Generate sage.platform signal with only truthful runtime facts."""
                  try:
                      # Only include facts we can truthfully measure
                      facts = {
                          "process_running": True,
                          "python_version": sys.version.split()[0],
                          "service_name": "sage-api"
                      }
                      
                      # Check if we're in Kubernetes (truthful check via env vars)
                      if os.getenv("KUBERNETES_SERVICE_HOST"):
                          facts["in_kubernetes"] = True
                          facts["kubernetes_service_host"] = os.getenv("KUBERNETES_SERVICE_HOST")
                      else:
                          facts["in_kubernetes"] = False
                      
                      return {
                          "id": "sage.platform",
                          "source": "sage",
                          "state": "ok",
                          "severity": "info",
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "platform",
                              "summary": "Service process running and responding",
                              "facts": facts
                          }
                      }
                  except Exception:
                      # If we can't assess, emit unavailable
                      return {
                          "id": "sage.platform",
                          "source": "sage",
                          "state": "unavailable",
                          "severity": "unavailable",
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "platform",
                              "summary": "Cannot assess platform state",
                              "facts": {}
                          }
                      }
              
              def get_gitops_signal(self, timestamp):
                  """Generate sage.gitops signal. Emits unavailable if no GitOps status source exists."""
                  # No existing Flux API client or reconciliation status source found in codebase
                  # Per requirements: do NOT fake it - emit unavailable
                  return {
                      "id": "sage.gitops",
                      "source": "sage",
                      "state": "unavailable",
                      "severity": "unavailable",
                      "timestamp": timestamp,
                      "metadata": {
                          "domain": "gitops",
                          "summary": "GitOps reconciliation status not accessible - no status source available",
                          "facts": {}
                      }
                  }
              
              def check_kubernetes_api(self):
                  """Check if Kubernetes API is accessible. Returns (accessible: bool, gitops_accessible: bool)."""
                  try:
                      # Check if we're in Kubernetes
                      if not os.getenv("KUBERNETES_SERVICE_HOST"):
                          return (False, False)
                      
                      # Try to access Kubernetes API using service account token
                      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                      ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                      api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                      api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                      
                      if not os.path.exists(token_path) or not os.path.exists(ca_cert_path):
                          return (False, False)
                      
                      # Read token
                      with open(token_path, 'r') as f:
                          token = f.read().strip()
                      
                      # Try to query Flux Kustomizations to check GitOps
                      api_url = f"https://{api_host}:{api_port}/apis/kustomize.toolkit.fluxcd.io/v1/namespaces/flux-system/kustomizations"
                      
                      # Create SSL context with CA cert
                      context = ssl.create_default_context(cafile=ca_cert_path)
                      
                      # Make request
                      req = Request(api_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      
                      opener = build_opener(HTTPSHandler(context=context))
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  return (True, True)
                      except (URLError, HTTPError, OSError):
                          # API accessible but GitOps query failed or no permissions
                          return (True, False)
                      
                      return (True, False)
                  except Exception:
                      # Any failure - cannot determine
                      return (False, False)
              
              def get_reconciliation_status(self, timestamp):
                  """Get reconciliation status. Returns status dict or None on failure."""
                  try:
                      cycle_id = timestamp
                      interval_seconds = 30
                      
                      # Check what we can observe
                      k8s_accessible, gitops_accessible = self.check_kubernetes_api()
                      
                      observed_targets = {
                          "gitops": gitops_accessible,
                          "kubernetes": k8s_accessible,
                          "external": False
                      }
                      
                      # If we can't observe anything, return unknown
                      if not k8s_accessible:
                          return {
                              "cycle_id": cycle_id,
                              "status": "unknown",
                              "last_successful_reconcile": None,
                              "interval_seconds": interval_seconds,
                              "observed_targets": observed_targets,
                              "notes": "Cannot access Kubernetes API to determine reconciliation status"
                          }
                      
                      # If we can access GitOps, try to get actual status
                      if gitops_accessible:
                          try:
                              token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                              ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                              api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                              api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                              
                              with open(token_path, 'r') as f:
                                  token = f.read().strip()
                              
                              api_url = f"https://{api_host}:{api_port}/apis/kustomize.toolkit.fluxcd.io/v1/namespaces/flux-system/kustomizations"
                              
                              context = ssl.create_default_context(cafile=ca_cert_path)
                              req = Request(api_url)
                              req.add_header("Authorization", f"Bearer {token}")
                              
                              opener = build_opener(HTTPSHandler(context=context))
                              with opener.open(req, timeout=2) as resp:
                                  if resp.getcode() == 200:
                                      data = json.loads(resp.read().decode())
                                      
                                      # Check Kustomization statuses
                                      items = data.get("items", [])
                                      if not items:
                                          return {
                                              "cycle_id": cycle_id,
                                              "status": "unknown",
                                              "last_successful_reconcile": None,
                                              "interval_seconds": interval_seconds,
                                              "observed_targets": observed_targets,
                                              "notes": "No Kustomizations found"
                                          }
                                      
                                      # Analyze status conditions
                                      all_ready = True
                                      any_stalled = False
                                      last_success = None
                                      
                                      for item in items:
                                          conditions = item.get("status", {}).get("conditions", [])
                                          for cond in conditions:
                                              if cond.get("type") == "Ready":
                                                  status = cond.get("status", "").lower()
                                                  if status != "true":
                                                      all_ready = False
                                                  if cond.get("reason") == "ReconciliationSuspended" or "stalled" in cond.get("message", "").lower():
                                                      any_stalled = True
                                                  # If Ready=True, use lastTransitionTime as last successful reconcile
                                                  if status == "true":
                                                      last_reconcile = cond.get("lastTransitionTime")
                                                      if last_reconcile and (not last_success or last_reconcile > last_success):
                                                          last_success = last_reconcile
                                      
                                      # Determine status
                                      if any_stalled:
                                          status = "stalled"
                                      elif all_ready:
                                          status = "aligned"
                                      else:
                                          status = "drifting"
                                      
                                      return {
                                          "cycle_id": cycle_id,
                                          "status": status,
                                          "last_successful_reconcile": last_success,
                                          "interval_seconds": interval_seconds,
                                          "observed_targets": observed_targets,
                                          "notes": None
                                      }
                          except Exception:
                              # Failed to parse or query - return unknown
                              pass
                      
                      # Fallback: we can see Kubernetes but not GitOps details
                      return {
                          "cycle_id": cycle_id,
                          "status": "unknown",
                          "last_successful_reconcile": None,
                          "interval_seconds": interval_seconds,
                          "observed_targets": observed_targets,
                          "notes": "Kubernetes accessible but GitOps reconciliation status cannot be determined"
                      }
                  except Exception:
                      # Any exception - return unknown
                      return {
                          "cycle_id": timestamp,
                          "status": "unknown",
                          "last_successful_reconcile": None,
                          "interval_seconds": 30,
                          "observed_targets": {
                              "gitops": False,
                              "kubernetes": False,
                              "external": False
                          },
                          "notes": "Exception during reconciliation check"
                      }
              
              def get_reconciliation_signal(self, timestamp):
                  """Generate sage.reconciliation signal from reconciliation status."""
                  try:
                      recon_status = self.get_reconciliation_status(timestamp)
                      status = recon_status["status"]
                      
                      # Map status to severity (LOCKED mapping)
                      severity_map = {
                          "aligned": "info",
                          "drifting": "notice",
                          "stalled": "warning",
                          "unknown": "unavailable"
                      }
                      severity = severity_map.get(status, "unavailable")
                      
                      return {
                          "id": "sage.reconciliation",
                          "source": "sage",
                          "state": status,
                          "severity": severity,
                          "timestamp": timestamp,
                          "metadata": {
                              "cycle_id": recon_status["cycle_id"],
                              "observed_targets": recon_status["observed_targets"],
                              "last_successful_reconcile": recon_status["last_successful_reconcile"],
                              "interval_seconds": recon_status["interval_seconds"],
                              "notes": recon_status["notes"]
                          }
                      }
                  except Exception:
                      # If signal generation fails, return unavailable
                      return {
                          "id": "sage.reconciliation",
                          "source": "sage",
                          "state": "unknown",
                          "severity": "unavailable",
                          "timestamp": timestamp,
                          "metadata": {
                              "cycle_id": timestamp,
                              "observed_targets": {
                                  "gitops": False,
                                  "kubernetes": False,
                                  "external": False
                              },
                              "last_successful_reconcile": None,
                              "interval_seconds": 30,
                              "notes": "Signal generation failed"
                          }
                      }
              
              def get_adrae_signal(self, timestamp):
                  """
                  Observe ADRAE rhythm state and normalize into SAGE signal.
                  
                  Architectural note: SAGE is the sole observer of ADRAE. UI/HADRA never
                  talk to ADRAE directly by design - they observe ADRAE indirectly through
                  SAGE signals. ADRAE remains sovereign and unaware of observers.
                  """
                  try:
                      # Internal HTTP GET to ADRAE using cluster-local networking
                      # Timeout quickly (â‰¤2s) and catch ALL exceptions
                      adrae_url = "http://adrae.adrae.svc.cluster.local:8000/api/adrae/rhythm"
                      
                      req = Request(adrae_url)
                      opener = build_opener()
                      
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() != 200:
                                  # Non-200 response - emit unavailable
                                  return {
                                      "id": "adrae.rhythm",
                                      "source": "adrae",
                                      "state": "unavailable",
                                      "severity": "unavailable",
                                      "timestamp": timestamp,
                                      "metadata": {
                                          "summary": "ADRAE returned non-200 status",
                                          "cadence_ms": None,
                                          "continuity": None,
                                          "last_tick": None,
                                          "notes": f"HTTP {resp.getcode()}"
                                      }
                                  }
                              
                              # Parse ADRAE response
                              data = json.loads(resp.read().decode())
                              adrae_state = data.get("state", "unavailable")
                              
                              # Map ADRAE state to severity
                              severity_map = {
                                  "focused": "info",
                                  "active": "info",
                                  "idle": "notice",
                                  "degraded": "warning",
                                  "unavailable": "unavailable"
                              }
                              severity = severity_map.get(adrae_state, "unavailable")
                              
                              # Extract metadata from ADRAE response
                              metadata = {
                                  "cadence_ms": data.get("cadence_ms"),
                                  "continuity": data.get("continuity"),
                                  "last_tick": data.get("last_tick"),
                                  "notes": data.get("notes")
                              }
                              
                              return {
                                  "id": "adrae.rhythm",
                                  "source": "adrae",
                                  "state": adrae_state,
                                  "severity": severity,
                                  "timestamp": timestamp,
                                  "metadata": metadata
                              }
                      except (URLError, HTTPError, OSError, TimeoutError) as e:
                          # ADRAE cannot be reached or connection failed
                          return {
                              "id": "adrae.rhythm",
                              "source": "adrae",
                              "state": "unavailable",
                              "severity": "unavailable",
                              "timestamp": timestamp,
                              "metadata": {
                                  "summary": "ADRAE is not reachable",
                                  "cadence_ms": None,
                                  "continuity": None,
                                  "last_tick": None,
                                  "notes": "Connection failed or timeout"
                              }
                          }
                  except Exception:
                      # Any other exception - emit unavailable
                      return {
                          "id": "adrae.rhythm",
                          "source": "adrae",
                          "state": "unavailable",
                          "severity": "unavailable",
                          "timestamp": timestamp,
                          "metadata": {
                              "summary": "ADRAE observation failed",
                              "cadence_ms": None,
                              "continuity": None,
                              "last_tick": None,
                              "notes": "Exception during ADRAE observation"
                          }
                      }
              
              def get_chi_presence_signal(self, timestamp):
                  """
                  Observe Chi structural presence (idle-safe observation).
                  Read-only Kubernetes API checks for namespace and deployment existence.
                  """
                  try:
                      # Check if we can access Kubernetes API
                      if not os.getenv("KUBERNETES_SERVICE_HOST"):
                          return {
                              "id": "chi.presence",
                              "source": "chi",
                              "state": "unavailable",
                              "severity": "unavailable",
                              "timestamp": timestamp,
                              "metadata": {
                                  "domain": "presence",
                                  "summary": "Cannot assess Chi presence - not in Kubernetes",
                                  "facts": {}
                              }
                          }
                      
                      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                      ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                      api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                      api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                      
                      if not os.path.exists(token_path) or not os.path.exists(ca_cert_path):
                          return {
                              "id": "chi.presence",
                              "source": "chi",
                              "state": "unavailable",
                              "severity": "unavailable",
                              "timestamp": timestamp,
                              "metadata": {
                                  "domain": "presence",
                                  "summary": "Cannot assess Chi presence - no service account",
                                  "facts": {}
                              }
                          }
                      
                      with open(token_path, 'r') as f:
                          token = f.read().strip()
                      
                      context = ssl.create_default_context(cafile=ca_cert_path)
                      
                      # Check namespace existence
                      namespace_url = f"https://{api_host}:{api_port}/api/v1/namespaces/arc-chi"
                      req = Request(namespace_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      opener = build_opener(HTTPSHandler(context=context))
                      
                      namespace_exists = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  namespace_exists = True
                      except (URLError, HTTPError, OSError):
                          pass
                      
                      # Check deployment existence and pod status
                      deployment_url = f"https://{api_host}:{api_port}/apis/apps/v1/namespaces/arc-chi/deployments/chi-idle"
                      req = Request(deployment_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      
                      pod_running = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  data = json.loads(resp.read().decode())
                                  available_replicas = data.get("status", {}).get("availableReplicas") or 0
                                  pod_running = (available_replicas >= 1)
                      except (URLError, HTTPError, OSError):
                          pass
                      
                      # Determine state
                      if namespace_exists and pod_running:
                          state = "idle"
                          severity = "info"
                      elif namespace_exists:
                          state = "ready"
                          severity = "notice"
                      else:
                          state = "unavailable"
                          severity = "unavailable"
                      
                      return {
                          "id": "chi.presence",
                          "source": "chi",
                          "state": state,
                          "severity": severity,
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "presence",
                              "summary": "Chi structural presence observed",
                              "facts": {
                                  "namespace_exists": namespace_exists,
                                  "pod_running": pod_running,
                                  "mode": "idle",
                                  "readiness": "structural_only"
                              }
                          }
                      }
                  except Exception:
                      # Any exception - emit unavailable
                      return {
                          "id": "chi.presence",
                          "source": "chi",
                          "state": "unavailable",
                          "severity": "unavailable",
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "presence",
                              "summary": "Chi presence observation failed",
                              "facts": {}
                          }
                      }
              
              def get_chi_bus_readiness_signal(self, timestamp):
                  """
                  Observe Chi bus readiness for NATS activation (idle-safe observation).
                  Read-only Kubernetes API checks for service, endpoints, and network policies.
                  """
                  try:
                      # Check if we can access Kubernetes API
                      if not os.getenv("KUBERNETES_SERVICE_HOST"):
                          return {
                              "id": "chi.bus_readiness",
                              "source": "chi",
                              "state": "unavailable",
                              "severity": "unavailable",
                              "timestamp": timestamp,
                              "metadata": {
                                  "domain": "readiness",
                                  "summary": "Cannot assess Chi bus readiness - not in Kubernetes",
                                  "facts": {}
                              }
                          }
                      
                      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                      ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                      api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                      api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                      
                      if not os.path.exists(token_path) or not os.path.exists(ca_cert_path):
                          return {
                              "id": "chi.bus_readiness",
                              "source": "chi",
                              "state": "unavailable",
                              "severity": "unavailable",
                              "timestamp": timestamp,
                              "metadata": {
                                  "domain": "readiness",
                                  "summary": "Cannot assess Chi bus readiness - no service account",
                                  "facts": {}
                              }
                          }
                      
                      with open(token_path, 'r') as f:
                          token = f.read().strip()
                      
                      context = ssl.create_default_context(cafile=ca_cert_path)
                      opener = build_opener(HTTPSHandler(context=context))
                      
                      # Check service existence
                      service_url = f"https://{api_host}:{api_port}/api/v1/namespaces/arc-chi/services/chi-bus"
                      req = Request(service_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      
                      service_exists = False
                      ports_configured = {}
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  service_exists = True
                                  data = json.loads(resp.read().decode())
                                  ports = data.get("spec", {}).get("ports", [])
                                  for port in ports:
                                      port_name = port.get("name", "")
                                      port_num = port.get("port", 0)
                                      if port_name == "client" or port_num == 4222:
                                          ports_configured["client"] = 4222
                                      if port_name == "monitor" or port_num == 8222:
                                          ports_configured["monitor"] = 8222
                      except (URLError, HTTPError, OSError):
                          pass
                      
                      # Check endpoints existence and population
                      endpoints_url = f"https://{api_host}:{api_port}/api/v1/namespaces/arc-chi/endpoints/chi-bus"
                      req = Request(endpoints_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      
                      endpoints_populated = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  data = json.loads(resp.read().decode())
                                  subsets = data.get("subsets", [])
                                  if subsets:
                                      for subset in subsets:
                                          addresses = subset.get("addresses", [])
                                          if addresses:
                                              endpoints_populated = True
                                              break
                      except (URLError, HTTPError, OSError):
                          pass
                      
                      # Check network policy existence (CiliumNetworkPolicy)
                      netpol_url = f"https://{api_host}:{api_port}/apis/cilium.io/v2/namespaces/arc-chi/ciliumnetworkpolicies/chi-ingress"
                      req = Request(netpol_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      
                      network_policy_active = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  network_policy_active = True
                      except (URLError, HTTPError, OSError):
                          pass
                      
                      # Determine state
                      if service_exists and network_policy_active:
                          if endpoints_populated:
                              state = "ready"
                              severity = "info"
                              ready_for_activation = True
                          else:
                              state = "ready"
                              severity = "notice"
                              ready_for_activation = False
                      elif service_exists:
                          state = "ready"
                          severity = "notice"
                          ready_for_activation = False
                      else:
                          state = "unavailable"
                          severity = "unavailable"
                          ready_for_activation = False
                      
                      return {
                          "id": "chi.bus_readiness",
                          "source": "chi",
                          "state": state,
                          "severity": severity,
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "readiness",
                              "summary": "Chi bus readiness assessment",
                              "facts": {
                                  "service_exists": service_exists,
                                  "endpoints_populated": endpoints_populated,
                                  "network_policy_active": network_policy_active,
                                  "ports_configured": ports_configured if ports_configured else None,
                                  "ready_for_activation": ready_for_activation
                              }
                          }
                      }
                  except Exception:
                      # Any exception - emit unavailable
                      return {
                          "id": "chi.bus_readiness",
                          "source": "chi",
                          "state": "unavailable",
                          "severity": "unavailable",
                          "timestamp": timestamp,
                          "metadata": {
                              "domain": "readiness",
                              "summary": "Chi bus readiness observation failed",
                              "facts": {}
                          }
                      }
              
              def _get_arc_presence_signal(self, timestamp, source_id, namespace, deployment_name):
                  """Idle-safe observation: namespace + deployment. Same shape as Chi."""
                  try:
                      if not os.getenv("KUBERNETES_SERVICE_HOST"):
                          return {"id": f"{source_id}.presence", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": f"Cannot assess {source_id} presence - not in Kubernetes", "facts": {}}}
                      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                      ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                      api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                      api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                      if not os.path.exists(token_path) or not os.path.exists(ca_cert_path):
                          return {"id": f"{source_id}.presence", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": f"Cannot assess {source_id} presence - no service account", "facts": {}}}
                      with open(token_path, 'r') as f:
                          token = f.read().strip()
                      context = ssl.create_default_context(cafile=ca_cert_path)
                      namespace_url = f"https://{api_host}:{api_port}/api/v1/namespaces/{namespace}"
                      req = Request(namespace_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      opener = build_opener(HTTPSHandler(context=context))
                      namespace_exists = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  namespace_exists = True
                      except (URLError, HTTPError, OSError):
                          pass
                      deployment_url = f"https://{api_host}:{api_port}/apis/apps/v1/namespaces/{namespace}/deployments/{deployment_name}"
                      req = Request(deployment_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      pod_running = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  data = json.loads(resp.read().decode())
                                  available_replicas = data.get("status", {}).get("availableReplicas") or 0
                                  pod_running = (available_replicas >= 1)
                      except (URLError, HTTPError, OSError):
                          pass
                      if namespace_exists and pod_running:
                          state, severity = "idle", "info"
                      elif namespace_exists:
                          state, severity = "ready", "notice"
                      else:
                          state, severity = "unavailable", "unavailable"
                      return {"id": f"{source_id}.presence", "source": source_id, "state": state, "severity": severity, "timestamp": timestamp, "metadata": {"domain": "presence", "summary": f"{source_id} structural presence observed", "facts": {"namespace_exists": namespace_exists, "pod_running": pod_running, "mode": "idle", "readiness": "structural_only"}}}
                  except Exception:
                      return {"id": f"{source_id}.presence", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": f"{source_id} presence observation failed", "facts": {}}}
              
              def _get_arc_bus_readiness_signal(self, timestamp, source_id, namespace, service_name, cnp_name):
                  """Idle-safe observation: service, endpoints, CNP. Same shape as Chi."""
                  try:
                      if not os.getenv("KUBERNETES_SERVICE_HOST"):
                          return {"id": f"{source_id}.bus_readiness", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": f"Cannot assess {source_id} bus readiness - not in Kubernetes", "facts": {}}}
                      token_path = "/var/run/secrets/kubernetes.io/serviceaccount/token"
                      ca_cert_path = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
                      api_host = os.getenv("KUBERNETES_SERVICE_HOST")
                      api_port = os.getenv("KUBERNETES_SERVICE_PORT", "443")
                      if not os.path.exists(token_path) or not os.path.exists(ca_cert_path):
                          return {"id": f"{source_id}.bus_readiness", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": f"Cannot assess {source_id} bus readiness - no service account", "facts": {}}}
                      with open(token_path, 'r') as f:
                          token = f.read().strip()
                      context = ssl.create_default_context(cafile=ca_cert_path)
                      opener = build_opener(HTTPSHandler(context=context))
                      service_url = f"https://{api_host}:{api_port}/api/v1/namespaces/{namespace}/services/{service_name}"
                      req = Request(service_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      service_exists = False
                      ports_configured = {}
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  service_exists = True
                                  data = json.loads(resp.read().decode())
                                  for port in data.get("spec", {}).get("ports", []):
                                      if port.get("name") == "client" or port.get("port") == 4222:
                                          ports_configured["client"] = 4222
                                      if port.get("name") == "monitor" or port.get("port") == 8222:
                                          ports_configured["monitor"] = 8222
                      except (URLError, HTTPError, OSError):
                          pass
                      endpoints_url = f"https://{api_host}:{api_port}/api/v1/namespaces/{namespace}/endpoints/{service_name}"
                      req = Request(endpoints_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      endpoints_populated = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  data = json.loads(resp.read().decode())
                                  for subset in data.get("subsets", []):
                                      if subset.get("addresses"):
                                          endpoints_populated = True
                                          break
                      except (URLError, HTTPError, OSError):
                          pass
                      netpol_url = f"https://{api_host}:{api_port}/apis/cilium.io/v2/namespaces/{namespace}/ciliumnetworkpolicies/{cnp_name}"
                      req = Request(netpol_url)
                      req.add_header("Authorization", f"Bearer {token}")
                      network_policy_active = False
                      try:
                          with opener.open(req, timeout=2) as resp:
                              if resp.getcode() == 200:
                                  network_policy_active = True
                      except (URLError, HTTPError, OSError):
                          pass
                      if service_exists and network_policy_active:
                          state, severity = "ready", "info" if endpoints_populated else "notice"
                          ready_for_activation = endpoints_populated
                      elif service_exists:
                          state, severity, ready_for_activation = "ready", "notice", False
                      else:
                          state, severity, ready_for_activation = "unavailable", "unavailable", False
                      return {"id": f"{source_id}.bus_readiness", "source": source_id, "state": state, "severity": severity, "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": f"{source_id} bus readiness assessment", "facts": {"service_exists": service_exists, "endpoints_populated": endpoints_populated, "network_policy_active": network_policy_active, "ports_configured": ports_configured if ports_configured else None, "ready_for_activation": ready_for_activation}}}
                  except Exception:
                      return {"id": f"{source_id}.bus_readiness", "source": source_id, "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": f"{source_id} bus readiness observation failed", "facts": {}}}
              
              def handle_request(self):
                  timestamp = datetime.utcnow().isoformat() + 'Z'
                  
                  # Always return HTTP 200, never throw
                  try:
                      if self.path == '/api/sage/reconciliation':
                          # Reconciliation status endpoint
                          recon_status = self.get_reconciliation_status(timestamp)
                          response = recon_status
                          self.send_response(200)
                          self.send_header('Content-Type', 'application/json')
                          self.send_cors_headers()
                          self.end_headers()
                          self.wfile.write(json.dumps(response).encode())
                          return
                      
                      elif self.path == '/api/sage/signals':
                          # SAGE Signal Emission endpoint
                          # Includes ADRAE observation: SAGE is the sole observer of ADRAE.
                          # UI/HADRA observe ADRAE indirectly through SAGE signals only.
                          # Includes Chi + NATS-participating arcs: idle-safe presence and bus readiness signals.
                          signals = [
                              self.get_platform_signal(timestamp),
                              self.get_gitops_signal(timestamp),
                              self.get_reconciliation_signal(timestamp),
                              self.get_adrae_signal(timestamp),
                              self.get_chi_presence_signal(timestamp),
                              self.get_chi_bus_readiness_signal(timestamp),
                              self._get_arc_presence_signal(timestamp, "sigma", "arc-sigma", "sigma-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "sigma", "arc-sigma", "sigma-bus", "sigma-ingress"),
                              self._get_arc_presence_signal(timestamp, "omega", "arc-omega", "omega-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "omega", "arc-omega", "omega-bus", "omega-ingress"),
                              self._get_arc_presence_signal(timestamp, "lambda", "arc-lambda", "lambda-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "lambda", "arc-lambda", "lambda-bus", "lambda-ingress"),
                              self._get_arc_presence_signal(timestamp, "mu", "arc-mu", "mu-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "mu", "arc-mu", "mu-bus", "mu-ingress"),
                              self._get_arc_presence_signal(timestamp, "nu", "arc-nu", "nu-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "nu", "arc-nu", "nu-bus", "nu-ingress"),
                              self._get_arc_presence_signal(timestamp, "zeta", "arc-zeta", "zeta-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "zeta", "arc-zeta", "zeta-bus", "zeta-ingress"),
                              self._get_arc_presence_signal(timestamp, "xi", "arc-xi", "xi-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "xi", "arc-xi", "xi-bus", "xi-ingress"),
                              self._get_arc_presence_signal(timestamp, "omicron", "arc-omicron", "omicron-idle"),
                              self._get_arc_bus_readiness_signal(timestamp, "omicron", "arc-omicron", "omicron-bus", "omicron-ingress"),
                          ]
                          response = {"signals": signals}
                          self.send_response(200)
                          self.send_header('Content-Type', 'application/json')
                          self.send_cors_headers()
                          self.end_headers()
                          self.wfile.write(json.dumps(response).encode())
                          return
                      
                      # Existing endpoints
                      self.send_response(200)
                      self.send_header('Content-Type', 'application/json')
                      self.send_cors_headers()
                      self.end_headers()
                      
                      if self.path == '/api/status':
                          response = {
                              "status": "ok",
                              "timestamp": timestamp,
                              "service": "sage-api"
                          }
                      elif self.path == '/api/whisperer':
                          response = {
                              "message": "Whisperer endpoint ready",
                              "timestamp": timestamp
                          }
                      elif self.path == '/api/auth/status':
                          response = {
                              "authenticated": False,
                              "user": None,
                              "timestamp": timestamp
                          }
                      else:
                          self.send_response(404)
                          self.end_headers()
                          response = {"error": "Not found"}
                      
                      self.wfile.write(json.dumps(response).encode())
                  except Exception:
                      # Critical: Never throw - always return HTTP 200
                      # If anything fails, return unknown status
                      try:
                          self.send_response(200)
                          self.send_header('Content-Type', 'application/json')
                          self.send_cors_headers()
                          self.end_headers()
                          
                          if self.path == '/api/sage/reconciliation':
                              response = {
                                  "cycle_id": timestamp,
                                  "status": "unknown",
                                  "last_successful_reconcile": None,
                                  "interval_seconds": 30,
                                  "observed_targets": {
                                      "gitops": False,
                                      "kubernetes": False,
                                      "external": False
                                  },
                                  "notes": "Exception during request handling"
                              }
                          elif self.path == '/api/sage/signals':
                              response = {
                                  "signals": [
                                      {
                                          "id": "sage.reconciliation",
                                          "source": "sage",
                                          "state": "unknown",
                                          "severity": "unavailable",
                                          "timestamp": timestamp,
                                          "metadata": {
                                              "cycle_id": timestamp,
                                              "observed_targets": {
                                                  "gitops": False,
                                                  "kubernetes": False,
                                                  "external": False
                                              },
                                              "last_successful_reconcile": None,
                                              "interval_seconds": 30,
                                              "notes": "Exception during signal generation"
                                          }
                                      },
                                      {
                                          "id": "adrae.rhythm",
                                          "source": "adrae",
                                          "state": "unavailable",
                                          "severity": "unavailable",
                                          "timestamp": timestamp,
                                          "metadata": {
                                              "summary": "ADRAE observation unavailable due to exception",
                                              "cadence_ms": None,
                                              "continuity": None,
                                              "last_tick": None,
                                              "notes": "Exception during request handling"
                                          }
                                      },
                                      {
                                          "id": "chi.presence",
                                          "source": "chi",
                                          "state": "unavailable",
                                          "severity": "unavailable",
                                          "timestamp": timestamp,
                                          "metadata": {
                                              "domain": "presence",
                                              "summary": "Chi presence observation unavailable due to exception",
                                              "facts": {}
                                          }
                                      },
                                      {
                                          "id": "chi.bus_readiness",
                                          "source": "chi",
                                          "state": "unavailable",
                                          "severity": "unavailable",
                                          "timestamp": timestamp,
                                          "metadata": {
                                              "domain": "readiness",
                                              "summary": "Chi bus readiness observation unavailable due to exception",
                                              "facts": {}
                                          }
                                      },
                                      {"id": "sigma.presence", "source": "sigma", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Sigma presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "sigma.bus_readiness", "source": "sigma", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Sigma bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "omega.presence", "source": "omega", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Omega presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "omega.bus_readiness", "source": "omega", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Omega bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "lambda.presence", "source": "lambda", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Lambda presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "lambda.bus_readiness", "source": "lambda", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Lambda bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "mu.presence", "source": "mu", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Mu presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "mu.bus_readiness", "source": "mu", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Mu bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "nu.presence", "source": "nu", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Nu presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "nu.bus_readiness", "source": "nu", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Nu bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "zeta.presence", "source": "zeta", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Zeta presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "zeta.bus_readiness", "source": "zeta", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Zeta bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "xi.presence", "source": "xi", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Xi presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "xi.bus_readiness", "source": "xi", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Xi bus readiness observation unavailable due to exception", "facts": {}}},
                                      {"id": "omicron.presence", "source": "omicron", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "presence", "summary": "Omicron presence observation unavailable due to exception", "facts": {}}},
                                      {"id": "omicron.bus_readiness", "source": "omicron", "state": "unavailable", "severity": "unavailable", "timestamp": timestamp, "metadata": {"domain": "readiness", "summary": "Omicron bus readiness observation unavailable due to exception", "facts": {}}}
                                  ]
                              }
                          else:
                              response = {"error": "Internal error"}
                          
                          self.wfile.write(json.dumps(response).encode())
                      except Exception:
                          # Last resort - minimal response
                          pass
          
          server = http.server.HTTPServer(('0.0.0.0', 3000), APIHandler)
          print("SAGE API server starting on port 3000...")
          server.serve_forever()
